#+TITLE: The Note of Advanced Algorithms
#+OPTIONS: num:nil
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup
#+startup: content

 zweite Semester für Computer Wissenschaft
* Master theorem
* Maximum increasing Subsequence
It has three different solution,
** LCS C++
** LCS python
** Dynamic program C++
#+begin_src C++ :results output
#include <iostream>  
using namespace std;  
#define len(a) (sizeof(a) / sizeof(a[0])) //数组长度  
int lis(int arr[], int len)  
{  
    int longest[len];  
    for (int i=0; i<len; i++)  
        longest[i] = 1;  
  
    for (int j=1; j<len; j++) {  
        for (int i=0; i<j; i++) {  
            if (arr[j]>arr[i] && longest[j]<longest[i]+1){ //注意longest[j]<longest[i]+1这个条件，不能省略。  
                longest[j] = longest[i] + 1; //计算以arr[j]结尾的序列的最长递增子序列长度  
            }  
        }  
    }  
  
    int max = 0;  
    for (int j=0; j<len; j++) {  
        cout << "longest[" << j << "]=" << longest[j] << endl;  
        if (longest[j] > max) max = longest[j];  //从longest[j]中找出最大值  
    }  
    return max;  
}  
  
int main()  
{  
    int arr[] = {1, 4, 5, 6, 2, 3, 8}; //测试数组  
    int ret = lis(arr, len(arr));  
    cout << "max increment substring len=" << ret << endl;  
    return 0;  
}  
#+end_src
#+RESULTS:
: longest[0]=1
: longest[1]=2
: longest[2]=3
: longest[3]=4
: longest[4]=2
: longest[5]=3
: longest[6]=5
: max increment substring len=5

** Dynamic Program Python
#+begin_src python :results output
list1 = [2, 1, 3, 45, 76, 89, 457, 54, 4, 5, 3, 6, 7, 8, 4, 9]
l = len(list1)
a = [1]*l
b = [[] for x in range(l)]


for i in range(l):
    for j in range(i):
        if (list1[i] > list1[j]) and (a[i] < (a[j] + 1)):
            a[i] = a[j]+1
            b[i].append(list1[j])
    b[i].append(list1[i])

print(a)
maxa = a.index(max(a))
print("the maximun length of LIS of list1 is {}".format(max(a)))
print("the LIS is {}".format(b[maxa]))


#+end_src
#+RESULTS:
: [1, 1, 2, 3, 4, 5, 6, 4, 3, 4, 2, 5, 6, 7, 3, 8]
: the maximun length of LIS of list1 is 8
: the LIS is [2, 3, 4, 5, 6, 7, 8, 9]

** O(nlogn) method C++
#+begin_src C++ :results output
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  

#define N 9 //数组元素个数  
int array[N] = {2, 1, 6, 3, 5, 4, 8, 7, 9}; //原数组  
int B[N]; //在动态规划中使用的数组,用于记录中间结果,其含义三言两语说不清,请参见博文的解释  
int len; //用于标示B数组中的元素个数  

int LIS(int *array, int n); //计算最长递增子序列的长度,计算B数组的元素,array[]循环完一遍后,B的长度len即为所求  
int BiSearch(int *b, int len, int w); //做了修改的二分搜索算法  

int main()  
{
    
  printf("LIS: %d\n", LIS(array, N));  
      
  int i;  
  for(i=0; i<len; ++i)  
    {  
      printf("B[%d]=%d\n", i, B[i]);  
    }  

  return 0;  
}  

int LIS(int *array, int n)  
{  

  len = 1;  
  B[0] = array[0];  
  int i, pos = 0;
  int *lis =(int *) malloc(n*sizeof(int));
      
  lis[0] = array[0];
  for(i=1; i<n; ++i)  
    {  
      if(array[i] > B[len-1]) //如果大于B中最大的元素，则直接插入到B数组末尾  
	{  
	  B[len] = array[i];  
	  ++len;
	  lis[i] = array[i]; 
	}  
      else  
	{  
	  pos = BiSearch(B, len, array[i]); //二分查找需要插入的位置
	  lis[pos] = array[i];
	  B[pos] = array[i];  
	}
    }  

  printf("the LIS is :\n");
  for (int i = 0; i < n; ++i) {
    printf("%d ",lis[i]);
  }
  free(lis);
  printf(" \n");
  
  return len;  
}  

//修改的二分查找算法，返回数组元素需要插入的位置。  
int BiSearch(int *b, int len, int w)  
{  
  int left = 0, right = len - 1;  
  int mid;  
  while (left <= right)  
    {  
      mid = left + (right-left)/2;  
      if (b[mid] > w)  
	right = mid - 1;  
      else if (b[mid] < w)  
	left = mid + 1;  
      else    //找到了该元素，则直接返回  
	return mid;  
    }  
  return left;//数组b中不存在该元素，则返回该元素应该插入的位置  
}  




#+end_src

#+RESULTS:
: the LIS is :
: 1 3 4 7 5 0 8 0 9  
: LIS: 5
: B[0]=1
: B[1]=3
: B[2]=4
: B[3]=7
: B[4]=9

** O(nlogn) method Python
#+begin_src python :results output
list1 = [2, 1, 3, 4, 5, 3, 6, 7, 8, 4, 9]
l = len(list1)


def getpos(list2, n, x):  # binary search of postion
    left = 0
    right = n-1
    while (left <= right):
        mid = int(left + (right-left)/2)
        if x < list1[mid]:
            right = mid-1
        elif x > list1[mid]:
            left = mid + 1
        else:
            return mid
    return left


c = [list1[0]]  # copy the first element to c

for i in range(1, l):
    if c[-1] < list1[i]:  # if the new element is bigger than the last c, add it
        c.append(list1[i])
    else:
        pos = getpos(c, len(c), list1[i])  # if not, find the right pos
        c[pos-1] = list1[i]

print(c)

#+end_src

#+RESULTS:
: [1, 3, 4, 5, 6, 7, 8, 9]
* maximum submatrix
**  Brute force solution Python
#+begin_src python :results output
  import random
  l = 6
  a = [[]]*l
  gsm = [[]]*l
  for i in range(l):
      a[i] = [random.randint(-5, 5) for x in range(l)]

  print("Original random matrix  \n")
  for i in range(l):
      for j in range(l):
          print("{:>4d}".format(a[i][j]), end="")
      print("\n")

  max = 0

  # distance between x dimension of submatrix
  for i in range(1, l):
      for xstart in range(i-1, l):                            # x start  of submatrix
          for xstop in range(i+xstart, l+1-i+1):              # x stop    of submatrix
              # distance between y dimension of submatrix
              for j in range(1, l):
                  for ystart in range(j-1, l):                 # y start of submatrix
                      for ystop in range(j+ystart, l+1-j+1):   # y stop of submatrix
                          lip = [[] for x in range(l)]
                          count = 0
                          for x in range(xstart, xstop):
                              for y in range(ystart, ystop):
                                  lip[x].append(a[x][y])
                                  count += a[x][y]
                          if count > max:
                              lipmax = [[] for x in range(l)]
                              max = count
                              lipmax = lip
  print("maximux submatrix :\n")
  for i in range(len(lipmax)):
      print("\n")
      for j in lipmax[i]:
          print("{:>4d}".format(j), end="")

  print("\n")
  print("The summary is ", max)

#+end_src

#+RESULTS:
#+begin_example
Original random matrix  

   1   5   0  -5   2  -3

   3  -3  -2   1  -4  -1

  -1   2  -2   2   0  -1

   5  -1  -4  -4  -1  -4

   3  -2   2  -4  -5  -1

   0  -3   3   0  -3   3

maximux submatrix :



   1   5

   3  -3

  -1   2

   5  -1

   3  -2



The summary is  12
#+end_example

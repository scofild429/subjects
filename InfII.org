#+TITLE: The Note of Information II 
#+OPTIONS: num:nil
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup
#+startup: content

* Functional Programm of Haskell
** Grundlage
basic function call
#+begin_src haskell  :results value :eval (inferior-haskell-start-process)
  log2 :: Float -> Float
  log2 = logBase 2
log2 43

#+end_src

#+RESULTS:
: Prelude> 5.426264754702098

implication
#+begin_src haskell  :results value :eval (inferior-haskell-start-process)

  (==>):: Bool -> Bool -> Bool
  a ==> b = not a || not b
Flase ==> True
False==> False
True ==> True

#+end_src

#+RESULTS:
: False

--euler numbers
#+begin_src haskell  :results value :eval (inferior-haskell-start-process)

  e:: Float
    e = exp 1
e 
#+end_src

#+RESULTS:
: 2.718281828459045

** Pattern Matching

one of the calling must match one case of pattern
#+begin_src haskell 
  (<#>) :: Bool -> Bool -> Bool
    (<#>) False False = False
    (<#>) False True = True
    (<#>) True False = True
    (<#>) True True = True


  True <#> True
    #+end_src

#+RESULTS:
: Prelude> Prelude> Prelude> Prelude> Prelude> Prelude> True


#+begin_src  haskell  :results value :eval (inferior-haskell-start-process)

  (<#>) :: Bool -> Bool -> Bool
    (<#>) True True = True
    (<#>) _ _ = False

  (<#>) True True
  (<#>) False True

#+end_src

#+RESULTS:
: False

#+begin_src haskell
  (<#>) :: Bool -> Bool -> Bool
    (<#>) True True = True

#+end_src

case : this can only be executed in a .hs file,
 in orgmode can NOT be imported, I don't know what is going on
 in Terminal can NOT also

Here I made above mistake, this is no sense.
so long the indentation is correct, so works

#+begin_src haskell 
  (<#>) :: Bool -> Bool -> Bool
  (<#>) a b
    | a == b = False
    | otherwise = True


#+end_src

** Alternativen

if else then
#+begin_src haskell 
  absolute :: Int -> Int
  absolute x = if x < 0 then -x else x

#+end_src

** Recursion
easy fib
#+begin_src haskell
  heronA ::(Int, Double) -> Double
  heronA (n,a)
    | n > 0     = (heronA(n-1,a) + a/heronA(n-1, a))/2
    | otherwise = a

  absolute :: Int -> Int
  absolute x = if x < 0 then -x else x

  heronB :: Int -> Double -> Double
  heronB n a
    | n > 0     = (heronB (n-1) a + a/heronB(n-1) a)/2
    | otherwise = a

#+end_src


where 
#+begin_src haskell
  heronC :: Int -> Double -> Double
  heronC n a
    |n > 0      = (x + a/x)/2
    |otherwise  = a
    where x = heronC (n-1) a
#+end_src

fib & where

#+begin_src haskell
  fibA :: Int -> Int
  fibA n
    |n == 0    = 0
    |n == 1    = 1
    |otherwise = x +y
    where
      x = fibA (n-1)
      y = fibA (n-2)
 
#+end_src

fib & where & pattern matching

#+begin_src  haskell
  fibB :: Int -> Int
  fibB 0 = 0
  fibB 1 = 1
  fibB n = fibB (n-1) + fibB (n-2)


  fibC :: Int -> Int
  fibC 0 = 0
  fibC 1 = 1
  fibC n
    | n < 0      = error "illegal arguement"
    | otherwise  = fibB (n-1) + fibB (n-2)


  (<##>) :: Int -> Double -> Double
  0 <##> a   = a
  n <##> a  
    | n > 0  = (x + a/x)/2
    | otherwise  = error "illegal arguement"
    where x = (n-1) <##> a
#+end_src

** type conversion

Guides
#+begin_src haskell
  vielleichtdreifach :: Bool -> Bool -> Integer -> Integer
  vielleichtdreifach verdreifach nochmal n
    | verdreifach && nochmal = maldrei ( maldrei n)
    | verdreifach            = maldrei n
    | otherwise              = n
    where maldrei n = 3*n 

  dreifach :: Integer -> Integer
  dreifach = vielleichtdreifach True False 

  neudreifach :: Integer -> Integer
  neudreifach = vielleichtdreifach True True

#+end_src
vielleichtdreifach Bool Bool -> Integer

** Factorial
#+begin_src haskell
  fac :: Integer -> Integer
  fac n
    | n == 0  = 1
    | otherwise = fac (n-1) * n
#+end_src

** Stern Brocot Floge

$\\s_{0} = 0 \\ s_{1} = 1 \\ s_{2n} = s_{n} \\ s_{2n+1} = s_{n} + s_{n+1}$

#+begin_src  haskell
  (*/*) :: Integer -> Integer -> Integer
  (*/*) = div

  (*%*) :: Integer -> Integer -> Integer
  (*%*) = rem

  sternBrocot :: Integer -> Integer
  sternBrocot n
    | n == 0      = 0
    | n == 1      = 1
    | n *%* 2 == 0 = sternBrocot half
    | otherwise    = sternBrocot half + sternBrocot (half + 1)
    where half = n */* 2

  suche :: Integer -> Integer -> Integer
  suche suchziel postionziel
    | sternBrocot postionziel > suchziel = postionziel
    | otherwise                          = suche suchziel (postionziel +1)

#+end_src


* Schaltnetze
** COMMENT Gatter und Haskell
NOT AND OR NAND NOR

let can not as sentence  use alone, but can be as a part in main

#+begin_src haskell
  table_row :: ([Bool] -> Bool) -> [Bool] -> String
  table_row f xs = show xs ++ " : " ++ show(f xs)

  table :: ([Bool] -> Bool) -> [[Bool]] -> String
  table f xs
    |xs == [] = ""
    |otherwise = table_row f (head xs) ++ " \n " ++ table f (tail xs)

  main = do
    let boool_tri = [[ a,b,c ] | a <- [True, False, False],
                    b <- [False, True, False],
                    c <- [False, True, True]]

    putStrLn (table and boool_tri)


  tableA :: ([Bool] -> Bool) -> [[Bool]] -> String
  tableA f [] = ""
  tableA f (x:xs) = table_row f x ++ " \n  "++ tableA f xs
#+end_src
